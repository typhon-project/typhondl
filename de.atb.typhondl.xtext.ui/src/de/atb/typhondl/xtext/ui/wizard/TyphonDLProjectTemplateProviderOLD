/*
 * generated by Xtext 2.15.0
 */
package de.atb.typhondl.xtext.ui.wizard

import java.io.FileReader
import org.eclipse.core.runtime.Status
import org.eclipse.xtend.lib.annotations.Data
import org.eclipse.xtext.ui.XtextProjectHelper
import org.eclipse.xtext.ui.util.ProjectFactory
import org.eclipse.xtext.ui.wizard.template.IProjectGenerator
import org.eclipse.xtext.ui.wizard.template.IProjectTemplateProvider
import org.eclipse.xtext.ui.wizard.template.ProjectTemplate

import static org.eclipse.core.runtime.IStatus.*

import static extension com.google.common.io.CharStreams.*

/**
 * Create a list with all project templates to be shown in the template new project wizard.
 * 
 * Each template is able to generate one or more projects. Each project can be configured such that any number of files are included.
 */
class TyphonDLProjectTemplateProvider implements IProjectTemplateProvider {
	override getProjectTemplates() {
		#[new HelloWorldProject, new FirstTestProject]
	}
	
}

@ProjectTemplate(label="First Test", icon="typhon_icon.png", description="<p><b>First Test</b></p>
<p>This is a first try for TyphonDL. You can chose the dmbs</p>")
final class FirstTestProject {
	var mandatoryGroup = group("Mandatory")
	val pathToMLmodel = text("Path To ML-model", "C:\\Users\\flug\\eclipse-workspace-photon\\testing\\test.tml", "The path to your .tml file", mandatoryGroup) //TODO give this to class TyphonMLmodel
	val mlModel = new TyphonMLmodel
	val info = mlModel.getInfoFromML()
	
	val relationaldb = #["MariaDB", "MySQL"]
	val documentdb = #["MongoDB", "CouchDB"]
	val graphdb = #["ArangoDB", "Neo4j"]
	val keyvaluedb = #["ArangoDB", "Redis"]

	val loadModel = check("Use this ML model", false, mandatoryGroup)
	override protected updateVariables(){
		if (loadModel.value) {
			val test = combo("test", #["1", "2"])
//			val test = info.iterator.map[database |
//				val name = database.dbName
//				val type = database.dbType		
//				return combo(name, #["1","2"])
//			]
		}
	}

	val dbms = combo("DBMS:", #["MariaDB", "MongoDB", "ArangoDB", "MySQL"], "The DBMS for your data", mandatoryGroup) //TODO make more combos, separate by type
	override generateProjects(IProjectGenerator generator) {
		generator.generate(new ProjectFactory => [
			projectName = projectInfo.projectName
			location = projectInfo.locationPath
			projectNatures += XtextProjectHelper.NATURE_ID
			builderIds += XtextProjectHelper.BUILDER_ID
			addFile('''firstTest.tdl''', '''
				/*
				 * This is an example model
				 */
				«FOR db:info»
				container «db.dbName»
				myDB : «db.dbType»
				image = «dbms»
				«ENDFOR»
			''')
		])
	}
	
}

@ProjectTemplate(label="Hello World", icon="sample.png", description="<p><b>Hello World</b></p>
<p>This is a parameterized hello world for TyphonDL. You can set a parameter to modify the content in the generated file
and a parameter to set the package the file is created in.</p>")
final class HelloWorldProject {
	val advanced = check("Advanced:", false)
	val advancedGroup = group("Properties")
	val name = combo("Name:", #["Xtext", "World", "Foo", "Bar"], "The name to say 'Hello' to", advancedGroup)
	val path = text("Package:", "mydsl", "The package path to place the files in", advancedGroup)
	override protected updateVariables() {
		name.enabled = advanced.value
		path.enabled = advanced.value
		if (!advanced.value) {
			name.value = "Xtext"
			path.value = "tdl"
		}
	}
	override protected validate() {
		if (path.value.matches('[a-z][a-z0-9_]*(/[a-z][a-z0-9_]*)*'))
			null
		else
			new Status(ERROR, "Wizard", "'" + path + "' is not a valid package name")
	}
	override generateProjects(IProjectGenerator generator) {
		generator.generate(new ProjectFactory => [
			projectName = projectInfo.projectName
			location = projectInfo.locationPath
			projectNatures += XtextProjectHelper.NATURE_ID
			builderIds += XtextProjectHelper.BUILDER_ID
			addFile('''src/«path»/Model.tdl''', '''
				/*
				 * This is an example model
				 */
				Hello «name»!
			''')
		])
	}
}



@Data class DB {
    String dbName 
    String dbType
}

/**
 * @return List<Database> 
 */
class TyphonMLmodel {
	var pathToMLmodel = 'C:\\Users\\flug\\eclipse-workspace-photon\\testing\\test.tml' //TODO path übergeben
	/*
	 * create new FileReader, readLines (extension from Google Guava’s CharStreams) returns a List<String>. 
	 * The map extension expects a function as a parameter. It basically invokes that function for each value 
	 * in the list and returns another list containing the results of the function invocations.
	 * Within the lambda [] we process a single line from the text file and turn it into a Database by splitting 
	 * the string using the colon as the separator. String.split(String) returns a string array (String[]), 
	 * which Xtend auto-converts to a list when we call Iterable.iterator() on it.
	 */
	val infoFromML = new FileReader(pathToMLmodel).readLines.map[ line |
		val dbs = line.split(":").iterator
		return new DB(
			dbs.next,
			dbs.next
		)
	]
	
	def getInfoFromML() {
		return infoFromML
	}
	
}


