/*
 * generated by Xtext 2.15.0
 */
package de.atb.typhondl.xtext.validation

import de.atb.typhondl.xtext.typhonDL.Cluster
import de.atb.typhondl.xtext.typhonDL.Container
import de.atb.typhondl.xtext.typhonDL.DBType
import de.atb.typhondl.xtext.typhonDL.Key_KeyValueList
import de.atb.typhondl.xtext.typhonDL.Ports
import de.atb.typhondl.xtext.typhonDL.Property
import de.atb.typhondl.xtext.typhonDL.TyphonDLPackage
import java.io.BufferedReader
import java.io.InputStreamReader
import org.eclipse.xtext.validation.Check

import static extension com.google.common.io.CharStreams.*
import de.atb.typhondl.xtext.typhonDL.Platform
import de.atb.typhondl.xtext.typhonDL.Application

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class TyphonDLValidator extends AbstractTyphonDLValidator {

	public static val INVALID_PORT = 'invalidPort'
	public static val INVALID_DOCKER_KEY = 'invalidDockerKey'

	@Check
	def checkPorts(Key_KeyValueList key_keyValueList) {
		if (key_keyValueList.name.contains("port") || key_keyValueList.name.contains("Port")) {
			error("Use keyword \"ports\" to define ports", TyphonDLPackage.Literals.KEY_KEY_VALUE_LIST__PROPERTIES,
				INVALID_PORT)
		}
	}

	@Check
	def checkPorts(Ports ports) {
		for (port : ports.key_values) {
			if (!(port.name.equals("target") || port.name.equals("published"))) {
				error("Use \"target\" and/or \"published\" port", TyphonDLPackage.Literals.PORTS__KEY_VALUES)
			}
		}
	}

	@Check
	def checkPublishedPortUniqueness(Platform platform) {
		val apps = <Application>newArrayList
		platform.clusters.forEach[cluster|apps.addAll(cluster.applications)]
		val containers = <Container>newArrayList
		apps.forEach[app|containers.addAll(app.containers)]
		val portsList = <Ports>newArrayList
		containers.forEach[container|portsList.addAll(container.ports)]
		val publishedPorts = <String>newArrayList
		for (ports : portsList) {
			val publishedPort = ports.publishedPort
			if (publishedPorts.contains(publishedPort) && publishedPort !== null) {
				error("Published port " + publishedPort + " is appearing more than once, please change port",
					TyphonDLPackage.Literals.PLATFORM__TYPE)
			} else {
				publishedPorts.add(publishedPort)
			}
		}
	}

	def String getPublishedPort(Ports ports) {
		for (port : ports.key_values) {
			if (port.name.equals("published")) {
				return port.value
			}
		}
	}

	// the file is read every time a character is typed, maybe not the best approach.
	@Check // (CheckType.NORMAL) // for checking only on save or request only
	def checkComposeKeys(Cluster cluster) {
		val containers = <Container>newArrayList
		cluster.applications.forEach[app|containers.addAll(app.containers)]
		val properties = <Property>newArrayList
		containers.forEach[container|properties.addAll(container.properties)]
		var path = ""
		if (cluster.type.name.equalsIgnoreCase("DockerCompose")) {
			path = "de/atb/typhondl/xtext/validation/docker-compose_3.7.txt";
		} else if (cluster.type.name.equalsIgnoreCase("Kubernetes")) {
			path = "de/atb/typhondl/xtext/validation/kubernetes_v1.txt"
		}
		val inputStream = TyphonDLValidator.classLoader.getResourceAsStream(path)
		val bufferedReader = new BufferedReader(new InputStreamReader(inputStream))
		val keys = bufferedReader.readLines
		for (property : properties) {
			if (!keys.contains(property.name)) {
				if (property.name.equals('hostname') || property.name.equals('container_name')) {
					error("\"" + property.name + "\" is an internal polystore keyword and can't be defined by the user",
						TyphonDLPackage.Literals.CLUSTER__TYPE, INVALID_DOCKER_KEY)
				} else {
					error("\"" + property.name + "\" is not a " + cluster.type.name + " keyword",
						TyphonDLPackage.Literals.CLUSTER__TYPE, INVALID_DOCKER_KEY)
				}
			}
		}
	}

	@Check
	def checkImage(DBType dbType) {
		if (!dbType.image.value.toLowerCase.contains(dbType.name.toLowerCase)) {
			warning("This image does not contain the name of the DB, are you sure it is the right image?",
				TyphonDLPackage.Literals.DB_TYPE__IMAGE, 'dbNameDiffersImage')
		}
	}

}
