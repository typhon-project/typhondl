/*
 * generated by Xtext 2.15.0
 */
/*-
 * #%L
 * de.atb.typhondl.xtext
 * %%
 * Copyright (C) 2018 - 2020 ATB
 * %%
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 * 
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License, v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is
 * available at https://www.gnu.org/software/classpath/license.html.
 * 
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 * #L%
 */
package de.atb.typhondl.xtext.validation

import de.atb.typhondl.xtext.typhonDL.Application
import de.atb.typhondl.xtext.typhonDL.Cluster
import de.atb.typhondl.xtext.typhonDL.Container
import de.atb.typhondl.xtext.typhonDL.ContainerType
import de.atb.typhondl.xtext.typhonDL.DBType
import de.atb.typhondl.xtext.typhonDL.Import
import de.atb.typhondl.xtext.typhonDL.Key_KeyValueList
import de.atb.typhondl.xtext.typhonDL.Key_ValueArray
import de.atb.typhondl.xtext.typhonDL.Key_Values
import de.atb.typhondl.xtext.typhonDL.Platform
import de.atb.typhondl.xtext.typhonDL.Ports
import de.atb.typhondl.xtext.typhonDL.Property
import de.atb.typhondl.xtext.typhonDL.Resources
import de.atb.typhondl.xtext.typhonDL.TyphonDLPackage
import java.io.BufferedReader
import java.io.InputStreamReader
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.runtime.Path
import org.eclipse.xtext.validation.Check

import static extension com.google.common.io.CharStreams.*

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class TyphonDLValidator extends AbstractTyphonDLValidator {

    public static val INVALID_PORT = 'invalidPort'
    public static val INVALID_DOCKER_KEY = 'invalidDockerKey'

    @Check
    def checkKey_KeyValueLists(Key_KeyValueList key_keyValueList) {
        val name = key_keyValueList.name
        if (name.contains("port") || name.contains("Port")) {
            error("Use keyword \"ports\" to define ports", TyphonDLPackage.Literals.KEY_KEY_VALUE_LIST__PROPERTIES,
                INVALID_PORT)
        }
        if (name.equalsIgnoreCase("command") || name.equalsIgnoreCase("cmd")) {
            warning("Using \"command\" will overwrite the database's starting command",
                TyphonDLPackage.Literals.KEY_VALUES__VALUE)
        }
    }

    @Check
    def checkKey_Values(Key_Values key_values) {
        val name = key_values.name
        if (name.equalsIgnoreCase("command") || name.equalsIgnoreCase("cmd")) {
            warning("Using \"command\" will overwrite the database's starting command",
                TyphonDLPackage.Literals.KEY_VALUES__VALUE)
        }
    }

    @Check
    def checkKey_ValueArrays(Key_ValueArray key_ValueArray) {
        val name = key_ValueArray.name
        if (name.equalsIgnoreCase("command") || name.equalsIgnoreCase("cmd")) {
            warning("Using \"command\" will overwrite the database's starting command",
                TyphonDLPackage.Literals.KEY_VALUE_ARRAY__VALUES)
        }
    }

    @Check
    def checkPorts(Ports ports) {
        for (port : ports.key_values) {
            if (!(port.name.equals("target") || port.name.equals("published"))) {
                error("Use \"target\" and/or \"published\" port", TyphonDLPackage.Literals.PORTS__KEY_VALUES)
            }
        }
    }

    @Check
    def checkPublishedPortUniqueness(Platform platform) {
        val apps = <Application>newArrayList
        platform.clusters.forEach[cluster|apps.addAll(cluster.applications)]
        val containers = <Container>newArrayList
        apps.forEach[app|containers.addAll(app.containers)]
        val portsList = <Ports>newArrayList
        containers.forEach[container|portsList.addAll(container.ports)]
        val publishedPorts = <String>newArrayList
        for (ports : portsList) {
            val publishedPort = ports.publishedPort
            if (publishedPorts.contains(publishedPort) && publishedPort !== null) {
                error("Published port " + publishedPort + " is appearing more than once, please change port",
                    TyphonDLPackage.Literals.PLATFORM__TYPE)
            } else {
                publishedPorts.add(publishedPort)
            }
        }
    }

    def String getPublishedPort(Ports ports) {
        for (port : ports.key_values) {
            if (port.name.equals("published")) {
                return port.value
            }
        }
    }

    // the file is read every time a character is typed, maybe not the best approach.
    @Check // (CheckType.NORMAL) // for checking only on save or request only
    def checkComposeKeys(Cluster cluster) {
        val containers = <Container>newArrayList
        cluster.applications.forEach[app|containers.addAll(app.containers)]
        val properties = <Property>newArrayList
        containers.forEach[container|properties.addAll(container.properties)]
        var path = ""
        if (cluster.type.name.equalsIgnoreCase("DockerCompose")) {
            path = "de/atb/typhondl/xtext/validation/docker-compose_3.7.txt";
        } else if (cluster.type.name.equalsIgnoreCase("Kubernetes")) {
            path = "de/atb/typhondl/xtext/validation/kubernetes_v1.txt"
        }
        val inputStream = TyphonDLValidator.classLoader.getResourceAsStream(path)
        val bufferedReader = new BufferedReader(new InputStreamReader(inputStream))
        val keys = bufferedReader.readLines
        for (property : properties) {
            if (!keys.contains(property.name)) {
                val propertyName = property.name
                if (propertyName.equals('hostname') || propertyName.equals('container_name')) {
                    error("\"" + propertyName + "\" is an internal polystore keyword and can't be defined by the user",
                        TyphonDLPackage.Literals.CLUSTER__TYPE, INVALID_DOCKER_KEY)
                } else if (propertyName.equals('command')) {
                    warning("Using \"command\" will overwrite the starting command of the DB, be careful",
                        TyphonDLPackage.Literals.CLUSTER__TYPE)
                } else {
                    error("\"" + propertyName + "\" is not a " + cluster.type.name + " keyword",
                        TyphonDLPackage.Literals.CLUSTER__TYPE, INVALID_DOCKER_KEY)
                }
            }
        }
    }

    @Check
    def checkImage(DBType dbType) {
        if (!dbType.image.value.toLowerCase.contains(dbType.name.toLowerCase)) {
            warning("This image does not contain the name of the DB, are you sure it is the right image?",
                TyphonDLPackage.Literals.DB_TYPE__IMAGE, 'dbNameDiffersImage')
        }
    }

    @Check
    def checkResources(Resources resources) {
        if (resources.limitCPU === null && resources.limitMemory === null && resources.reservationCPU === null &&
            resources.reservationMemory === null) {
            error("Please give a resource parameter", TyphonDLPackage.Literals.RESOURCES__LIMIT_CPU)
        }
    }

    @Check
    def checkKubernetesContainerNames(Container container) {
        val cluster = container.eContainer.eContainer as Cluster
        if (cluster.type.name.equalsIgnoreCase("Kubernetes")) {
            val pattern = "^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
            if (!container.name.matches(pattern)) {
                error("Containernames in Kubernetes can only contain lower case letters, numbers and '-'",
                    TyphonDLPackage.Literals.CONTAINER__NAME)
            }
        }
    }

    @Check
    def checkContainerType(ContainerType containerType) {
        if (!containerType.name.equalsIgnoreCase("Docker")) {
            error("Only Docker is supported", TyphonDLPackage.Literals.CONTAINER__TYPE)
        }
    }

    /**
     * import de.atb.typhondl.xtext.ui.technologies.SupportedTechnologies <br>
     * import de.atb.typhondl.xtext.ui.modelUtils.ModelService <br>
     * is not possible because adding the packages to the manifest is creating a dependency loop.
     * So this has to be changed if a new constant is added to the SupportedTechnology enum.
     */
    @Check
    def checkSupportedTechnologies(Cluster cluster) {
        val clusterTypeName = cluster.type.name
        if (!((clusterTypeName).equals("Kubernetes") || clusterTypeName.equals("DockerCompose"))) {
            error("Only DockerCompose and Kubernetes are supported as clustertypes",
                TyphonDLPackage.Literals.CLUSTER__TYPE)
        }
    }

    @Check
    def checkImports(Import imports) {
        val modelURI = imports.eResource.URI
        val importURI = modelURI.trimSegments(1).appendSegment(imports.relativePath)
        val file = ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(importURI.toPlatformString(true)));
        if (!file.exists) {
            error("File \"" + imports.relativePath + "\" does not exist", TyphonDLPackage.Literals.IMPORT__RELATIVE_PATH)
        }
    }

}
